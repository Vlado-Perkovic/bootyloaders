// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.2
// LVGL version: 8.3.4
// Project name: kraken_hunt

/**
 * @file ui_events.c
 *
 * @brief
 *
 * COPYRIGHT NOTICE: (c) 2023 Byte Lab Grupa d.o.o.
 * All rights reserved.
 */

//--------------------------------- INCLUDES ----------------------------------
#include "ui.h"
#include "wifi.h"
#include "telemetry.h"
#include "led.h"
#include "button.h"
#include "joystick.h"
#include "game_engine.h"

#include "math.h"
#include <string.h>

//---------------------------------- MACROS -----------------------------------

#define MAIN_THREAD_STACK_SIZE   (4096u)
#define MAIN_THREAD_PRIORITY     (5u)
#define BUTTON_THREAD_STACK_SIZE (1024U)
#define BUTTON_THREAD_PRIORITY   (5u)

#define TELEMETRY_PERIOD_MS (5000)

#define NO_TIMEOUT (UINT_MAX)

#define BUTTON_QUEUE_LEN (10u)

#define GRID_OFFSET       (20)
#define GRID_SCALE        (5)
#define MAP_OFFSET_X_AXIS (-163)
#define MAP_OFFSET_Y_AXIS (-118)

//-------------------------------- DATA TYPES ---------------------------------

//---------------------- PRIVATE FUNCTION PROTOTYPES --------------------------

/**
 * @brief private function for the main task
 *
 * It deals with all the logic handling, interrupts send signals
 * through a queue which this task handles appropriately
 */
static void _main_task();

/* PROVISION SCREEN FUNCTION PROTOTYPES */
/**
 * @brief button 1 provision screen function
 *
 */
static void _button_1_provision_screen();
/**
 * @brief button 2 provision screen function
 *
 */
static void _button_2_provision_screen();
/**
 * @brief button 3 provision screen function
 *
 */
static void _button_3_provision_screen();
/**
 * @brief button 4 provision screen function
 *
 */
static void _button_4_provision_screen();

/* MAIN SCREEN FUNCTION PROTOTYPES */
/**
 * @brief button 1 main screen function
 *
 */
static void _button_1_main_screen();
/**
 * @brief button 2 main screen function
 *
 */
static void _button_2_main_screen();
/**
 * @brief button 3 main screen function
 *
 */
static void _button_3_main_screen();
/**
 * @brief button 4 main screen function
 *
 */
static void _button_4_main_screen();

/* MAP SCREEN FUNCTION PROTOTYPES */
/**
 * @brief button 1 map screen function
 *.
 */
static void _button_1_map_screen();
/**
 * @brief button 2 map screen function
 *
 */
static void _button_2_map_screen();
/**
 * @brief button 3 map screen function
 *
 */
static void _button_3_map_screen();
/**
 * @brief button 4 map screen function
 *
 */
static void _button_4_map_screen();

/* END GAME SCREEN FUNCTION PROTOTYPES */
/**
 * @brief button 1 end game screen function
 *
 */
static void _button_1_end_game_screen();
/**
 * @brief button 2 end game screen function
 *
 */
static void _button_2_end_game_screen();
/**
 * @brief button 3 end game screen function
 *
 */
static void _button_3_end_game_screen();
/**
 * @brief button 4 end game screen function
 *
 */
static void _button_4_end_game_screen();

/**
 * @brief private function for starting the game
 *
 */
static void _start_game();

/* SCREEN ACTIONS FUNCTION PROTOTYPES */
/**
 * @brief function that calls the appropriate function based on button on provision screen
 *
 * @param button
 */
static void _ui_provision_screen_actions(button_id_t button);
/**
 * @brief function that calls the appropriate function based on button on main screen
 *
 * @param button
 */
static void _ui_main_screen_actions(button_id_t button);
/**
 * @brief function that calls the appropriate function based on button on map screen
 *
 * @param button
 */
static void _ui_map_screen_actions(button_id_t button);
/**
 * @brief function that calls the appropriate function based on button on end game screen
 *
 * @param button
 */
static void _ui_end_game_screen_actions(button_id_t button);

/* HELPER FUNCTIONS */
/**
 * @brief function that renders the map data onto the screen
 *
 * @param map instance of a map object
 */
static void _ui_render_map(game_map_t map);
/**
 * @brief function that runs the right function when button is pressed
 *
 * @param button instance of a button enum
 */
static void _ui_button_run(button_id_t button);

/**
 * @brief function that ends the game with either WIN or LOSE
 *
 * @param state instance of the game state
 */
static void _ui_end_game_with(game_state_t state);

/**
 * @brief function that sends event to the game engine queue
 *
 * @param event instance of an event enum
 */
static void _ui_send_event_to_game_engine(game_user_input_event_t event);

/* CALLBACKS */
/**
 * @brief Callback function for button_1 (GREEN LED)
 *
 * @param [in] p_arg - pointer to context object
 */
static void _btn_1_cb(void *p_arg);

/**
 * @brief Callback function for button_2 (BLUE LED)
 *
 * @param [in] p_arg - pointer to context object
 */
static void _btn_2_cb(void *p_arg);

/**
 * @brief Callback function for button_3 (START BUTTON)
 *
 * @param [in] p_arg - pointer to context object
 */
static void _btn_3_cb(void *p_arg);

/**
 * @brief Callback function for button_4 (RED LED)
 *
 * @param [in] p_arg - pointer to context object
 */
static void _btn_4_cb(void *p_arg);

/**
 * @brief private function that all the buttons share
 *
 * @param p_arg pointer to an object, context
 * @param button button enum
 */
static void _button_callback(void *p_arg, button_id_t button);

/**
 * @brief callback function for when a new object is focused in the weapons group
 *
 * @param p_group
 */
static void _weapons_group_focus_cb(lv_group_t *p_group);

/**
 * @brief callback function for fetching the kraken position
 *
 * @param p_msg pointer to the message with the kraken position
 */
static void _telemetry_kraken_position_callback(const char *p_msg);

/**
 * @brief callback for the telemetry callback that sends info to basecamp
 *
 * @param p_timer handle to the timer
 */
static void _telemetry_timer_callback(TimerHandle_t p_timer);

//------------------------- STATIC DATA & CONSTANTS ---------------------------
static QueueHandle_t  p_button_queue    = NULL;
static game_engine_t *p_game            = NULL;
static lv_group_t    *p_weapons_group   = NULL;
static game_state_t   state             = GAME_IN_PROGRESS;
static bool           b_is_provisioning = false;
static bool           b_is_light_on     = false;
static TimerHandle_t  p_telemetry_timer = NULL;
static char           json[100];

//------------------------------- GLOBAL DATA ---------------------------------
extern QueueHandle_t p_game_event_queue;
extern volatile bool b_is_movement_permited;
extern QueueHandle_t p_map_queue;
extern QueueHandle_t p_game_state_queue;
//------------------------------ PUBLIC FUNCTIONS -----------------------------

void wifi_on_status_change_callback(wifi_connection_status_t new_status)
{
    if(WIFI_CONNECTION_STATUS_CONNECTED == new_status)
    {
        lv_label_set_text(ui_wifiStatus, "WIFI CONNECTED");
        b_is_provisioning = false;
        /* when connected, init the telemetry  and start the timer */
        telemetry_init();

        if(NULL != p_telemetry_timer)
        {
            if(pdPASS != xTimerStart(p_telemetry_timer, 0))
            {
                printf("The timer could not be set into the Active state.\n");
            }
        }
    }

    if(WIFI_CONNECTION_STATUS_DISCONNECTED == new_status)
    {
        lv_label_set_text(ui_wifiStatus, "CONNECTION FAILED");
        b_is_provisioning = false;
    }
}

void start_provision(lv_event_t *e)
{
    /* TOGGLE PROVISION */
    if(false == b_is_provisioning)
    {
        b_is_provisioning = true;
        wifi_provision(WIFI_PROV_METHOD_BLE);
        lv_label_set_text(ui_wifiStatus, "WIFI PROVISIONING");
    }
    else
    {
        wifi_provision_stop();
        b_is_provisioning = false;
        lv_label_set_text(ui_wifiStatus, "PROV CANCELED");
    }
}

void connect_to_wifi(lv_event_t *e)
{
    wifi_connect();
}

void ui_event_startup_wifi(lv_event_t *e)
{
    /* wifi init upon startup */
    wifi_register_on_status_changed(&wifi_on_status_change_callback);
    wifi_init();
}

void ui_events_is_wifi_available(lv_event_t *e)
{
    /* update the status bar */
    bool b_is_provisioned = false;
    if(true == wifi_is_wifi_connected())
    {
        lv_label_set_text(ui_wifiStatus, "WIFI CONNECTED");
    }
    else if(WIFI_OK != wifi_is_provisioned(&b_is_provisioned) || (false == b_is_provisioned))
    {
        lv_label_set_text(ui_wifiStatus, "WIFI NOT AVAILABLE");
    }
    else
    {
        lv_label_set_text(ui_wifiStatus, "WIFI AVAILABLE");
    }
}

void ui_game_start_up(lv_event_t *e)
{
    /* touch button related start up */
    /* START THE GAME */
    if(true == wifi_is_wifi_connected())
    {
        _start_game();
    }
}

void exit_game(lv_event_t *e)
{
    /* in the main screen on the top left there is a button that exits the game */
    game_engine_delete(p_game);
    p_game = NULL;
    lv_group_del(p_weapons_group);
    p_weapons_group = NULL;
}

void ui_setup(lv_event_t *e)
{
    /* SETUP ALL LEDS */
    if((LED_ERR_NONE != led_init(LED_RED)) || (LED_ERR_NONE != led_init(LED_GREEN)) || (LED_ERR_NONE != led_init(LED_BLUE)))
    {
        printf("An error has occured with led init.\n");
    }

    /* SETUP ALL BUTTONS */
    if(((BUTTON_ERR_NONE != button_init(BUTTON_1, _btn_1_cb)) || (BUTTON_ERR_NONE != button_init(BUTTON_2, _btn_2_cb))
        || (BUTTON_ERR_NONE != button_init(BUTTON_3, _btn_3_cb)) || (BUTTON_ERR_NONE != button_init(BUTTON_4, _btn_4_cb))))
    {
        printf("An error has occured with button init.\n");
    }

    /* SETUP JOYSTICK */
    if((JOYSTICK_ERR_NONE != joystick_init(JOYSTICK_1)))
    {
        printf("An error has occured with joystick init.\n");
    }

    /* SETUP TELEMETRY CALLBACK */
    telemetry_driver_register_on_new_message(&_telemetry_kraken_position_callback);

    /* CREATE BUTTON QUEUE */
    if((NULL == p_button_queue))
    {
        p_button_queue = xQueueCreate(BUTTON_QUEUE_LEN, sizeof(button_id_t));

        if(NULL == p_button_queue)
        {
            printf("Creation of user interface queue failed.\n");
        }
    }
    /* create a telemetry timer for sending data to basecamp */
    if((NULL == p_telemetry_timer))
    {
        p_telemetry_timer = xTimerCreate("p_telemetry_timer",
                                         (TELEMETRY_PERIOD_MS / portTICK_PERIOD_MS),
                                         pdTRUE,
                                         NULL,
                                         (TimerCallbackFunction_t)_telemetry_timer_callback);

        if(NULL == p_telemetry_timer)
        {
            printf("Handle timer creation error..\n");
        }
    }

    /* CREATE MAIN TASK */
    if(pdPASS != xTaskCreate(&_main_task, "main task", MAIN_THREAD_STACK_SIZE, NULL, MAIN_THREAD_PRIORITY, NULL))
    {
        printf("Creation of user interface task failed.\n");
    }
}

void ui_make_weapons_group(lv_event_t *e)
{
    /* upon loading the main screen make the weapons group */
    if(NULL != p_weapons_group)
    {
        return;
    }
    p_weapons_group = lv_group_create();
    lv_group_set_focus_cb(p_weapons_group, &_weapons_group_focus_cb);
    lv_group_set_wrap(p_weapons_group, true);
    lv_group_add_obj(p_weapons_group, ui_Button4);
    lv_group_add_obj(p_weapons_group, ui_Button6);
    lv_group_add_obj(p_weapons_group, ui_Button1);

    lv_group_focus_obj(ui_Button4);
}

//---------------------------- PRIVATE FUNCTIONS ------------------------------

static void _main_task()
{
    button_id_t              button;
    joystick_direction_t     direction;
    game_user_input_event_t  event;
    joystick_relative_move_t move;
    game_map_t               map;

    for(;;)
    {
        /* poll the game engine for game state */
        if((GAME_IN_PROGRESS == state) && (NULL != p_game_state_queue))
        {
            if(xQueueReceive(p_game_state_queue, &state, 0) == pdPASS)
            {
                _ui_end_game_with(state);
            }
        }

        /* get the direction and move from joystick */
        if(JOYSTICK_ERR_NONE != joystick_direction_get(JOYSTICK_1, &direction))
        {
            printf("Failed to get the joystick direction. Defaults to MIDDLE.\n");
        }
        if(JOYSTICK_ERR_NONE != joystick_relative_move_get(JOYSTICK_1, &move))
        {
            printf("Failed to get the joystick move. Defaults to {0,0}.\n");
        }

        /* if the player is allowed to move, send the direction to the game_engine
         * This way we don't overload the queue in the game_engine. */
        if((lv_scr_act() == ui_MainScreen) && (GAME_IN_PROGRESS == state) && (true == b_is_movement_permited))
        {

            if((JOYSTICK_MIDDLE != direction))
            {
                event.event_type = PLAYER_MOVE_EVENT;
                event.delta_x    = move.delta_x;
                event.delta_y    = move.delta_y;

                b_is_movement_permited = false;
                _ui_send_event_to_game_engine(event);
            }
        }

        /* get map info and render to map screen */
        if((GAME_IN_PROGRESS == state) && (NULL != p_map_queue))
        {
            if(xQueueReceive(p_map_queue, &map, 0) == pdPASS)
            {
                _ui_render_map(map);
            }
        }
        /* poll for button interrupts */
        if(xQueueReceive(p_button_queue, &button, 0) == pdPASS)
        {
            _ui_button_run(button);
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

static void _ui_send_event_to_game_engine(game_user_input_event_t event)
{
    if(NULL != p_game_event_queue)
    {

        if(xQueueSend(p_game_event_queue, (void *)&event, (TickType_t)0) != pdPASS)
        {
            /* Failed to post the message */
            printf("FAILED TO POST A MESSAGE\n");
        }
    }
}

static void _ui_render_map(game_map_t map)
{
    /* some screen related translating */
    lv_obj_set_pos(ui_playerPanel,
                   (map.player_x * GRID_SCALE + GRID_OFFSET) + MAP_OFFSET_X_AXIS,
                   (240 - (map.player_y * GRID_SCALE + GRID_OFFSET)) + MAP_OFFSET_Y_AXIS);
    lv_obj_set_pos(ui_krakenPanel,
                   (map.kraken_x * GRID_SCALE + GRID_OFFSET) + MAP_OFFSET_X_AXIS,
                   (240 - (map.kraken_y * GRID_SCALE + GRID_OFFSET)) + MAP_OFFSET_Y_AXIS);

    char text_buffer[10];
    /* update the on screen values */
    snprintf(text_buffer, sizeof(text_buffer), "(%d,%d)", map.player_x, map.player_y);
    lv_label_set_text(ui_SubmarinePosition, text_buffer);
    lv_label_set_text(ui_mapLabelSubmarineNum, text_buffer);

    snprintf(text_buffer, sizeof(text_buffer), "%.0f m", DISTANCE(map.player_x, map.player_y, map.kraken_x, map.kraken_y));
    lv_label_set_text(ui_DistanceFromKraken, text_buffer);
    lv_label_set_text(ui_mapLabelDistanceNum, text_buffer);

    snprintf(text_buffer, sizeof(text_buffer), "(%d,%d)", map.kraken_x, map.kraken_y);
    lv_label_set_text(ui_KrakenPosition, text_buffer);
    lv_label_set_text(ui_mapLabelKrakenNum, text_buffer);
}

static void _ui_end_game_with(game_state_t state)
{
    /* END THE GAME */
    game_engine_delete(p_game);
    p_game = NULL;
    lv_group_del(p_weapons_group);
    p_weapons_group = NULL;

    /* SHOW END GAME SCREEN */
    _ui_screen_change(&ui_endGameScreen, LV_SCR_LOAD_ANIM_NONE, 10, 0, &ui_endGameScreen_screen_init);
    if(GAME_WIN == state)
    {
        lv_label_set_text(ui_gameResultLabel, "GAME WON! :)");
    }
    else
    {
        lv_label_set_text(ui_gameResultLabel, "GAME LOST! :(");
    }
}

static void _ui_button_run(button_id_t button)
{
    /* Done in this fashion so adding new screen and defining button actions is adding an if statement and defining actions for those
     * buttons in a function like here */
    if(ui_ProvisionScreen == lv_scr_act())
    {
        _ui_provision_screen_actions(button);
    }
    else if(ui_MainScreen == lv_scr_act())
    {
        _ui_main_screen_actions(button);
    }
    else if(ui_mapScreen == lv_scr_act())
    {
        _ui_map_screen_actions(button);
    }
    else if(ui_endGameScreen == lv_scr_act())
    {
        _ui_end_game_screen_actions(button);
    }
}

static void _ui_provision_screen_actions(button_id_t button)
{
    switch(button)
    {
        case BUTTON_1:
            _button_1_provision_screen();
            break;

        case BUTTON_2:
            _button_2_provision_screen();
            break;

        case BUTTON_3:
            _button_3_provision_screen();
            break;

        case BUTTON_4:
            _button_4_provision_screen();
            break;

        default:
            break;
    }
}

static void _ui_main_screen_actions(button_id_t button)
{
    switch(button)
    {
        case BUTTON_1:
            _button_1_main_screen();
            break;

        case BUTTON_2:
            _button_2_main_screen();
            break;

        case BUTTON_3:
            _button_3_main_screen();
            break;

        case BUTTON_4:
            _button_4_main_screen();
            break;

        default:
            break;
    }
}

static void _ui_map_screen_actions(button_id_t button)
{
    switch(button)
    {
        case BUTTON_1:
            _button_1_map_screen();
            break;

        case BUTTON_2:
            _button_2_map_screen();
            break;

        case BUTTON_3:
            _button_3_map_screen();
            break;

        case BUTTON_4:
            _button_4_map_screen();
            break;

        default:
            break;
    }
}

static void _ui_end_game_screen_actions(button_id_t button)
{
    switch(button)
    {
        case BUTTON_1:
            _button_1_end_game_screen();
            break;

        case BUTTON_2:
            _button_2_end_game_screen();
            break;

        case BUTTON_3:
            _button_3_end_game_screen();
            break;

        case BUTTON_4:
            _button_4_end_game_screen();
            break;

        default:
            break;
    }
}

/* PROVISION SCREEN BUTTON FUNCTIONS */
static void _button_1_provision_screen()
{
    /* DIVER NAME STUFF */
}

static void _button_2_provision_screen()
{
    /* CONNECT TO WIFI */
    wifi_connect();
}

static void _button_3_provision_screen()
{
    /* START THE GAME */
    if(true == wifi_is_wifi_connected())
    {
        _start_game();
    }
}

static void _button_4_provision_screen()
{
    /* TOGGLE PROVISION */
    if(false == b_is_provisioning)
    {
        b_is_provisioning = true;
        wifi_provision(WIFI_PROV_METHOD_BLE);
        lv_label_set_text(ui_wifiStatus, "WIFI PROVISIONING");
    }
    else
    {
        wifi_provision_stop();
        b_is_provisioning = false;
        lv_label_set_text(ui_wifiStatus, "PROV CANCELED");
    }
}

/* MAIN SCREEN BUTTON FUNCTIONS */
static void _button_1_main_screen()
{
    /* USE WEAPON */

    if(NULL == p_weapons_group)
    {
        return;
    }

    /* get focused object. based on the object, send the right event to queue */
    game_user_input_event_t event;

    if(ui_Button4 == *p_weapons_group->obj_focus)
    {
        /* fire torpedo */
        event.event_type = TORPEDO_FIRING_EVENT;
        _ui_send_event_to_game_engine(event);
    }
    else if(ui_Button6 == *p_weapons_group->obj_focus)
    {
        /* fire net */
        event.event_type = NET_FIRING_EVENT;

        _ui_send_event_to_game_engine(event);
    }
    else if(ui_Button1 == *p_weapons_group->obj_focus)
    {
        /* toggle the lights */
        if(true == b_is_light_on)
        {
            b_is_light_on = false;
            lv_obj_set_style_bg_color(ui_Panel7, lv_color_hex(0x0), LV_PART_MAIN | LV_STATE_DEFAULT);
            led_pattern_reset(LED_GREEN);
        }
        else
        {
            b_is_light_on = true;
            lv_obj_set_style_bg_color(ui_Panel7, lv_color_hex(0xEEDD82), LV_PART_MAIN | LV_STATE_DEFAULT);
            led_pattern_run(LED_GREEN, LED_PATTERN_KEEP_ON, NO_TIMEOUT);
        }
    }
}

static void _button_2_main_screen()
{
    /* reduce in size the current focused object and make it white */
    lv_obj_set_width(*p_weapons_group->obj_focus, 40);
    lv_obj_set_height(*p_weapons_group->obj_focus, 40);
    lv_obj_set_style_bg_color(*p_weapons_group->obj_focus, lv_color_hex(0xFFFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);

    /* GO TO RIGHT IN WEAPONS SELECT */
    lv_group_focus_next(p_weapons_group);
}

static void _button_3_main_screen()
{
    /* CHANGE TO MAP */
    _ui_screen_change(&ui_mapScreen, LV_SCR_LOAD_ANIM_NONE, 10, 0, &ui_mapScreen_screen_init);
}

static void _button_4_main_screen()
{
    /* reduce in size the current focused object and make it white */
    lv_obj_set_width(*p_weapons_group->obj_focus, 40);
    lv_obj_set_height(*p_weapons_group->obj_focus, 40);
    lv_obj_set_style_bg_color(*p_weapons_group->obj_focus, lv_color_hex(0xFFFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);

    /* GO TO LEFT IN WEAPONS SELECT */
    lv_group_focus_prev(p_weapons_group);
}

/* MAP SCREEN BUTTON FUNCTIONS */
static void _button_1_map_screen()
{
    /* DO NOTHING */
}

static void _button_2_map_screen()
{
    /* DO NOTHING */
}

static void _button_3_map_screen()
{
    /* TOGGLE SCREEN */
    _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 10, 0, &ui_MainScreen_screen_init);
}

static void _button_4_map_screen()
{
    /* DO NOTHING */
}

/* END GAME SCREEN BUTTON FUNCTIONS */

static void _button_1_end_game_screen()
{
    /* while in end game screen, click on any button resets the game */
    _start_game();
}

static void _button_2_end_game_screen()
{
    _start_game();
}

static void _button_3_end_game_screen()
{
    _start_game();
}

static void _button_4_end_game_screen()
{
    _start_game();
}

static void _start_game()
{
    /* START THE GAME */
    if(NULL != p_game)
    {
        printf("Game already initialized.\n");
        return;
    }
    p_game = game_engine_new();
    game_engine_start(p_game);

    /* set the global state of the game */
    state = GAME_IN_PROGRESS;
    _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 10, 0, &ui_MainScreen_screen_init);
}

/* CALLBACKS */
static void _weapons_group_focus_cb(lv_group_t *p_group)
{
    /* enlarge the focused object and make it red */
    lv_obj_set_width(*p_group->obj_focus, 55);
    lv_obj_set_height(*p_group->obj_focus, 55);
    lv_obj_set_style_bg_color(*p_group->obj_focus, lv_color_hex(0xFF1414), LV_PART_MAIN | LV_STATE_DEFAULT);
}

static void _telemetry_kraken_position_callback(const char *p_msg)
{
    /* set the starting position at the coordinates
        {
            "Monster": "Kraken",
            "position": [
            12,         ^
            25          |
            ]          here is the start
        }
    */
    const char *start = strstr(p_msg, "[");

    int x, y;

    game_user_input_event_t event;
    event.event_type = KRAKEN_MOVE_EVENT;
    if(start != NULL)
    {
        /* try to parse the two coordinates */
        if(sscanf(start, "[%d,%d]", &x, &y) == 2)
        {
            event.delta_x = x;
            event.delta_y = y;
            if(NULL != p_game_event_queue)
            {
                _ui_send_event_to_game_engine(event);
            }
        }
    }
    else
    {
        printf("Position not found in the message.\n");
    }
}

static void _telemetry_timer_callback(TimerHandle_t p_timer)
{

    /* Timer formats and sends the current location and diver name to the basecamp */
    const char *name = "Vlado";
    uint8_t     x    = 0;
    uint8_t     y    = 0;
    if(NULL != p_game)
    {
        x = p_game->map.player_x;
        y = p_game->map.player_y;
    }
    // Format JSON using snprintf
    snprintf(json,
             sizeof(json),
             "{"
             "  \"name\": \"%s\","
             "  \"location\": [%d,%d]"
             "}",
             name,
             x,
             y);
    telemetry_connection_status_update(json);
}

static void IRAM_ATTR _button_callback(void *p_arg, button_id_t button)
{
    if((NULL == p_button_queue))
    {
        return;
    }

    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    if(pdTRUE != xQueueSendFromISR(p_button_queue, &button, &xHigherPriorityTaskWoken))
    {
        /* SEND FAILED */
        return;
    }

    if(pdTRUE == xHigherPriorityTaskWoken)
    {
        portYIELD_FROM_ISR();
    }
}
//---------------------------- INTERRUPT HANDLERS -----------------------------
static void IRAM_ATTR _btn_1_cb(void *p_arg)
{
    _button_callback(p_arg, BUTTON_1);
}

static void IRAM_ATTR _btn_2_cb(void *p_arg)
{
    _button_callback(p_arg, BUTTON_2);
}

static void IRAM_ATTR _btn_3_cb(void *p_arg)
{
    _button_callback(p_arg, BUTTON_3);
}

static void IRAM_ATTR _btn_4_cb(void *p_arg)
{
    _button_callback(p_arg, BUTTON_4);
}

void move_player_test(lv_event_t *e)
{
    // Your code here
}
